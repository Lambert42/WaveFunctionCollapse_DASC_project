# 数据结构与算法  课程大作业：WFC算法实现

### 摘要

本项目是2019年春季数据结构与算法课程大作业，由孟凡强，孙亮，蔡斌共同完成。在这个项目中，我们使用**Python**实现了波函数塌缩算法(***WaveFunctionCollapse***, 以下简称***WFC***),  并将其实现为可供扩展调用的模块。在本文中我们将按照课程要求对我们的项目进行介绍，主要包括：


- 需求分析
- 算法实现
- 示例
- 组员分工
- 总结与评价

### 需求分析

如果我们需要以一张小小的图为指导生成一张具有相同特征，或者说风格相似的大大的图，应该怎么做呢？也许









#### WFC算法简介

***WaveFunctionCollapse*** 算法是由Maxim Gumin等人于2016年提出的，是一种非回溯的贪心搜索算法。最早呈现于一个`GitHub`项目[WFC](<https://github.com/mxgmn/WaveFunctionCollapse>),  是采用C#语言进行实现的。算法的构想借鉴于量子力学中的波函数塌缩过程，用于随机生成与输入位图风格相似的位图。那么什么是所谓的“风格相似”的位图呢？Gumin 将其归结为两个条件：

>1. 输出中每一种大小为$N \times N$的图案(pattern)都应至少在输入中出现一次。
>2. (弱条件)  输入中$N\times N$图案的分布应类似于足够大量输出上的$N\times N$模式的分布。 换言之，输出中某个图案出现的概率应接近输入中该模式出现的频次。
>(强条件)  输出中某个图案出现的概率的极限应收敛于输入中该模式出现的频次。

由此可见，$N\times N$ 大小的图案将是算法采集和分析输入位图局部特征的最小单元。也就是说，$N$ 将决定算法的输出在多大程度上模仿输入的局部特征。可以想象的是，$N$ 太小时，输出受到的约束更少，结果将更混乱，难以完整地再现输入的特征；$N$ 太大时，输出将大块大块的复制输入而缺少随机性。所以参数 $N$ 的选择对于算法的运行十分重要，之后我们将对此再次讨论。

下面是一个简单的样例，





类比于量子力学中体系波函数和叠加态的概念，***WFC*** 算法首先将待输出的位图初始化一个未被观测过的波函数。其每一个格点的像素值都是输入位图中的像素值的叠加（例如，若输入是黑色块与白色块，那么尚未观测的像素点就是灰色的）。不同于量子力学的是，这里的叠加系数都是实数而非一般的复数。接下来，我们进入观测-传播循环：

- 挑选信息熵最小的未观测格点，将这个格点的状态随机塌缩为其状态空间中的某一个态。随机塌缩过程的权重则依赖与相应的图案在输入中出现的频次。
- 格点塌缩后，根据图案之间相邻近的约束，将塌缩的影响向四周的格点传播。

不断循环观测的过程直至所有格点都完成了塌缩，整个体系的状态就被确定下来了。当然，算法运行过程中有可能出现某个格点已经没有了可取的状态，此时接下来的过程将无法继续进行。考虑到生成一个满足前述条件的非平凡位图是一个NP问题，并不存在既高效又稳定的方法，故Gumin的解决方案是放弃之前的结果，让程序重新开始运行直至出现合适的结果。有趣的是，在实际的运用过程中，极少出现这样崩溃的情况。

在整个观测过程中，每次选择信息熵最小的点进行塌缩是一个十分精妙的构想，这使得每一次塌缩都从最接近确定的格点开始，而最终获得的输出竟能乱中有序。算法的提出者Gumin在其程序的介绍文件中写道：

>  “ I noticed that when humans draw something they often follow the minimal entropy heuristic themselves. That’s why the algorithm is so enjoyable to watch. ” 

正是这样的选择使得尽管 ***WFC*** 算法的输出不是简单机械地堆叠输入以获得一张更大的图样，而是仿佛有意识般地绘制，以至于能还原出输入图像的风格乃至神韵。下面，我们就来分析实现这个算法的具体细节。



### 需求分析

虽然`GItHub`上已有了许多实现 ***WFC*** 算法的项目，其中也包括采用 **Python** 语言的。但我们小组仍希望能够自己实现这个有趣好玩的算法，并希望加入一个简单的图形界面以方便使用。同时，虽然算法的初衷是为了求解开放性的、非唯一解的约束问题，我们还想将这个算法用在其他解唯一的约束问题中（比如数独问题）。此时，回溯就变得十分重要了。简言之，我们想做的事情有：

- 实现 ***WFC*** 算法，将之一般化为一个可以求解二维约束问题的模块
- 加入可根据需求选择的回溯操作
- 加入图形界面







#### 程序实现

基于之前的分析，我们的项目自然地分为两个部分，即核心算法的实现和图形界面的编写。





### 构想(雾

- #### 数据结构

  - 格点：记录该点的状态空间和(香农)熵。状态空间为可取状态及其权重的字典 { state : weight }。[香农熵](<https://en.wikipedia.org/wiki/Entropy_(information_theory)>)定义为

  $$
  S=-\sum_i \left(p_i \ln p_i\right)=-\sum_i \frac{w_i}{\sum w_i} \ln{\frac{w_i}{\sum w_i}}
  $$

  - (整体)波函数：包含格点的矩阵，为了方便单独记录其大小(size)。

- #### 

